// ConsoleApplication1.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "pch.h"
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <fstream>
#include <stdlib.h>
#include <string.h>
#include <vector>
#include <unordered_map>
using namespace std;

class FlatFileParser
{

public:
	class Field
	{
	public:
		int startIndex;
		int size;
		char* fieldName;
		char* fieldData;
	};

	vector<Field*> vFields;
	unordered_map<char*, Field*> mapFields;
	int totalSize;
	char* completeStr;

	void readData();
	void readSchema();
	void writeData();
	void printFields();
};

void FlatFileParser::writeData()
{
	completeStr = new char[totalSize + 1];
	completeStr[0] = '\0';
	for (Field* f : vFields)
	{
		strncat(completeStr, f->fieldData, f->size);
	}
	cout << "Total string : " << completeStr << endl;

}

void FlatFileParser::readSchema()
{
	char input[] = "\"field1\",4|\"field2\",4|\"field3\",8";

	vector<char*> vTokens;
	char* pch;
	pch = strtok(input, "|");
	while (pch != NULL)
	{
		vTokens.push_back(pch);
		pch = strtok(NULL, "|");
	}


	int localIndex = 0;
	totalSize = 0;
	for (char* tok : vTokens)
	{
		Field* f = new Field();
		f->fieldName = _strdup(strtok(tok, ","));
		f->startIndex = localIndex;
		f->size = atoi(strtok(NULL, ","));
		localIndex = localIndex + f->size;
		vFields.push_back(f);
		mapFields[f->fieldName] = f;
		totalSize += f->size;
	}
}

void FlatFileParser::printFields()
{
	for (Field* f : vFields)
	{
		cout << "Field : " << f->startIndex << " " << f->size << " " << f->fieldName << " " << f->fieldData << endl;
	}
}

int main() {

	FlatFileParser ffp;
	ffp.readSchema();
	ffp.readData();
	ffp.printFields();
	ffp.writeData();

	return 0;
}

void FlatFileParser::readData()
{
	std::ifstream is("C:\\Users\\giris\\Downloads\\BinaryData.bin", std::ifstream::binary);
	if (is) {
		// get length of file:
		is.seekg(0, is.end);
		int length = is.tellg();
		is.seekg(0, is.beg);

		char * buffer = new char[length];

		std::cout << "Reading " << length << " characters... ";
		// read data as a block:
		is.read(buffer, 16);
		buffer[16] = '\0';

		if (is)
			std::cout << "all characters read successfully. buffer : " << buffer << endl;
		else
			std::cout << "error: only " << is.gcount() << " could be read";
		is.close();

		// copy to field.fieldData
		for (Field* f : vFields)
		{
			f->fieldData = new char[f->size];
			strncpy(f->fieldData, buffer + f->startIndex, f->size);
			f->fieldData[f->size] = '\0';
		}

		delete[] buffer;
	}
}
